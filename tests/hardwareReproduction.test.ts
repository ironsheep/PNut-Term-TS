/** @format */

import { CircularBuffer } from '../src/classes/shared/circularBuffer';
import { MessageExtractor, MessageType, ExtractedMessage } from '../src/classes/shared/messageExtractor';
import { DynamicQueue } from '../src/classes/shared/dynamicQueue';
import { MessageRouter, RouteDestination } from '../src/classes/shared/messageRouter';
import { PooledMessage } from '../src/classes/shared/messagePool';

/**
 * MockDebugLogger - Captures messages sent to Debug Logger for testing
 */
class MockDebugLogger implements RouteDestination {
  public name = 'MockDebugLogger';
  private receivedMessages: (ExtractedMessage | PooledMessage)[] = [];
  private processedMessages: ExtractedMessage[] = [];

  public handler = (message: ExtractedMessage | PooledMessage): void => {
    console.log(`[MockDebugLogger] Received ${message.type} (${message.data.length} bytes)`);
    this.receivedMessages.push(message);
    
    // Extract actual data for analysis
    if ('poolId' in message) {
      // PooledMessage - extract data
      this.processedMessages.push({
        type: message.type,
        data: message.data,
        timestamp: message.timestamp,
        confidence: 'DISTINCTIVE' // Default confidence for pooled messages
      });
    } else {
      // Direct ExtractedMessage
      this.processedMessages.push(message);
    }
  }

  public getReceivedMessages(): (ExtractedMessage | PooledMessage)[] {
    return this.receivedMessages;
  }

  public getProcessedMessages(): ExtractedMessage[] {
    return this.processedMessages;
  }

  public getDebuggerPackets(): ExtractedMessage[] {
    return this.processedMessages.filter(m => m.type === MessageType.DEBUGGER_80BYTE);
  }

  public getCOGMessages(): ExtractedMessage[] {
    return this.processedMessages.filter(m => m.type === MessageType.COG_MESSAGE);
  }

  public reset(): void {
    this.receivedMessages = [];
    this.processedMessages = [];
  }
}

describe('Hardware Test Reproduction', () => {
  let buffer: CircularBuffer;
  let extractor: MessageExtractor;
  let outputQueue: DynamicQueue<ExtractedMessage>;
  let extractedMessages: ExtractedMessage[];

  beforeEach(() => {
    buffer = new CircularBuffer();
    outputQueue = new DynamicQueue<ExtractedMessage>(1000);
    extractor = new MessageExtractor(buffer, outputQueue);
    extractedMessages = [];
  });

  function feedDataAndExtract(data: Uint8Array, packetName: string): void {
    console.log(`\n=== FEEDING ${packetName}: ${data.length} bytes ===`);
    
    // Add data to buffer using the correct method
    const appended = buffer.appendAtTail(data);
    if (!appended) {
      console.error(`Failed to append ${data.length} bytes to buffer!`);
      return;
    }
    
    // Extract messages
    extractor.extractMessages();
    
    // Collect any new messages
    let message;
    while ((message = outputQueue.dequeue())) {
      extractedMessages.push(message);
      const preview = message.data.length > 0 ? new TextDecoder().decode(message.data.slice(0, Math.min(50, message.data.length))) : '';
      console.log(`EXTRACTED: ${message.type} - ${message.data.length} bytes - "${preview}"`);
    }
  }

  it('should reproduce exact hardware test sequence', () => {
    // Packet 1: 186 bytes (COG messages)
    const packet1 = new Uint8Array([
      0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x49, 0x4E, 0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30,  // Cog0  INIT $000
      0x5F, 0x30, 0x30, 0x30, 0x30, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x30, 0x30, 0x30,  // _0000 $0000_000
      0x20, 0x6C, 0x6F, 0x61, 0x64, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x49, 0x4E, 0x49,  //  load..Cog0  INI
      0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30, 0x30,  // T $0000_0F5C $00
      0x30, 0x30, 0x5F, 0x31, 0x43, 0x36, 0x38, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43, 0x6F,  // 00_1C68 jump..Co
      0x67, 0x30, 0x20, 0x20, 0x68, 0x69, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x64, 0x65, 0x62, 0x75,  // g0  hi from debu
      0x67, 0x20, 0x64, 0x65, 0x6D, 0x6F, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x31, 0x20, 0x20, 0x49, 0x4E,  // g demo..Cog1  IN
      0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30,  // IT $0000_0F5C $0
      0x30, 0x30, 0x30, 0x5F, 0x31, 0x38, 0x33, 0x34, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43,  // 000_1834 jump..C
      0x6F, 0x67, 0x32, 0x20, 0x20, 0x49, 0x4E, 0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F,  // og2  INIT $0000_
      0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x31, 0x41, 0x33, 0x34, 0x20,  // 0F5C $0000_1A34 
      0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x30                                        // jump..Cog0
    ]);
    
    // Packet 2: COG messages + COG1 debugger packet (exactly ends after 80-byte packet)
    const packet2 = new Uint8Array([
      0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x73, 0x20, 0x72, 0x75, 0x6E, 0x2C, 0x20, 0x4D, 0x61, 0x69,  //   Tasks run, Mai
      0x6E, 0x20, 0x6E, 0x6F, 0x77, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x69, 0x6E, 0x67, 0x21, 0x0D, 0x0A,  // n now looping!..
      0x43, 0x6F, 0x67, 0x31, 0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x65,  // Cog1  Task in ne
      0x77, 0x20, 0x43, 0x4F, 0x47, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0D, 0x0A, 0x43,  // w COG started..C
      0x6F, 0x67, 0x32, 0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x65, 0x77,  // og2  Task in new
      0x20, 0x43, 0x4F, 0x47, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0D, 0x0A, 0x01, 0x00,  //  COG started....
      // === COG1 80-byte debugger packet starts here ===
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x00, 0xA1, 0x03, 0xF8, 0x01, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x85, 0x22, 0x40, 0x00, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x5F, 0x02, 0x00, 0x40, 0x5D, 0x1C, 0x00, 0x00, 0x4C, 0x18, 0x00, 0x00,
      0x00, 0x00, 0x08, 0x00, 0x80, 0xB2, 0xE6, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x40, 0x2F
      // === COG1 packet ends exactly here (removed final 2 bytes) ===
    ]);

    // Packet 3: 124 bytes (COG2 debugger packet + padding)
    const packet3 = new Uint8Array([
      // === COG 2 DEBUGGER PACKET: 0x02 + 79 bytes of debugger data ===
      0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x00, 0xA2, 0x03, 0xF8, 0x02, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x86, 0x23, 0x41, 0x00, 0xFF, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x60, 0x02, 0x00, 0x41, 0x5E, 0x1D, 0x00, 0x00, 0x4D, 0x19, 0x00, 0x00,
      0x00, 0x00, 0x09, 0x00, 0x81, 0xB3, 0xE7, 0x0F, 0x11, 0x00, 0x00, 0x00, 0x41, 0x30, 0x41, 0x30,
      // === More COG2 debugger data ===
      0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30,
      0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30,
      // === Padding zeros (as seen in hardware test) ===
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ]);

    // Packet 4: Post-debugger ASCII messages to test system recovery
    const packet4 = new Uint8Array([
      // "Cog0  Post-debug message 1\r\n"  
      0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x50, 0x6F, 0x73, 0x74, 0x2D, 0x64, 0x65, 0x62, 0x75, 0x67,
      0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x31, 0x0D, 0x0A,
      // "Cog1  Post-debug message 2\r\n"
      0x43, 0x6F, 0x67, 0x31, 0x20, 0x20, 0x50, 0x6F, 0x73, 0x74, 0x2D, 0x64, 0x65, 0x62, 0x75, 0x67,
      0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x32, 0x0D, 0x0A
    ]);

    // Packet 5: Additional zeros (original padding)
    const packet5 = new Uint8Array([
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ]);

    // Feed data in exact same order and sizes as hardware test
    feedDataAndExtract(packet1, "PACKET 1 (186 bytes)");
    feedDataAndExtract(packet2, "PACKET 2 (372 bytes)"); 
    feedDataAndExtract(packet3, "PACKET 3 (124 bytes) - COG2 DEBUGGER");
    feedDataAndExtract(packet4, "PACKET 4 (56 bytes) - POST-DEBUG ASCII");
    feedDataAndExtract(packet5, "PACKET 5 (26 bytes) - PADDING");

    console.log(`\n=== FINAL ANALYSIS ===`);
    console.log(`Total messages extracted: ${extractedMessages.length}`);
    
    // Expected based on visual inspection of hex dumps:
    // STRINGS (should be COG_MESSAGE):
    // - "Cog0  INIT $0000_0000 $0000_0000 load\r\n"
    // - "Cog0  INIT $0000_0F5C $0000_1C68 jump\r\n"  
    // - "Cog0  hi from debug demo\r\n"
    // - "Cog1  INIT $0000_0F5C $0000_1834 jump\r\n"
    // - "Cog2  INIT $0000_0F5C $0000_1A34 jump\r\n"
    // - "Cog0  Tasks run, Main now looping!\r\n"
    // - "Cog1  Task in new COG started\r\n"
    // - "Cog2  Task in new COG started\r\n"
    // - "Cog0  Post-debug message 1\r\n"
    // - "Cog1  Post-debug message 2\r\n"
    //
    // BINARY PACKETS (should be DEBUGGER_80BYTE):
    // - COG 1: 80 bytes starting with 0x01
    // - COG 2: 80 bytes starting with 0x02
    
    const cogMessages = extractedMessages.filter(m => m.type === MessageType.COG_MESSAGE);
    const debuggerPackets = extractedMessages.filter(m => m.type === MessageType.DEBUGGER_80BYTE);
    const terminalOutput = extractedMessages.filter(m => m.type === MessageType.TERMINAL_OUTPUT);
    const systemInit = extractedMessages.filter(m => m.type === MessageType.P2_SYSTEM_INIT);
    
    console.log(`COG_MESSAGE: ${cogMessages.length} (expected: 8 strings)`);
    console.log(`DEBUGGER_80BYTE: ${debuggerPackets.length} (expected: 2 packets)`); 
    console.log(`TERMINAL_OUTPUT: ${terminalOutput.length} (expected: 0 - everything should be classified as COG_MESSAGE)`);
    console.log(`P2_SYSTEM_INIT: ${systemInit.length}`);
    
    // Print what we actually got for debugging
    console.log('\n=== ACTUAL EXTRACTIONS ===');
    extractedMessages.forEach((msg, i) => {
      const preview = new TextDecoder().decode(msg.data.slice(0, 30));
      console.log(`${i+1}. ${msg.type}: "${preview}..." (${msg.data.length} bytes)`);
    });
    
    // Verify we get the expected data structure (corrected expectations)
    expect(cogMessages.length).toBe(8); // Should have exactly 8 COG message strings (8 original initialization messages)
    expect(terminalOutput.length).toBe(0); // Should have ZERO terminal output - everything should be COG_MESSAGE  
    expect(debuggerPackets.length).toBe(2); // Should have exactly 2 debugger packets (COG1 + COG2) - FIXED!
    
    // Verify both debugger packets
    expect(debuggerPackets[0].data[0]).toBe(0x01); // COG 1
    expect(debuggerPackets[1].data[0]).toBe(0x02); // COG 2
  });

  it('should deliver both COG1 and COG2 packets through full pipeline to Debug Logger', async () => {
    // === SETUP FULL PIPELINE ===
    const mockDebugLogger = new MockDebugLogger();
    const routerQueue = new DynamicQueue<ExtractedMessage>(1000);
    const router = new MessageRouter(routerQueue); 
    
    // Register Debug Logger to receive DEBUGGER_80BYTE and COG_MESSAGE types
    router.registerDestination(MessageType.DEBUGGER_80BYTE, mockDebugLogger);
    router.registerDestination(MessageType.COG_MESSAGE, mockDebugLogger);
    
    console.log('\n=== FULL PIPELINE TEST ===');
    
    // === STEP 1: EXTRACT MESSAGES ===
    console.log('\n--- STEP 1: MESSAGE EXTRACTION ---');
    
    // Use exact same packet data as previous test
    const packet1 = new Uint8Array([
      0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x49, 0x4E, 0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30,  
      0x5F, 0x30, 0x30, 0x30, 0x30, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x30, 0x30, 0x30,  
      0x20, 0x6C, 0x6F, 0x61, 0x64, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x49, 0x4E, 0x49,  
      0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30, 0x30,  
      0x30, 0x30, 0x5F, 0x31, 0x43, 0x36, 0x38, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43, 0x6F,  
      0x67, 0x30, 0x20, 0x20, 0x68, 0x69, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x64, 0x65, 0x62, 0x75,  
      0x67, 0x20, 0x64, 0x65, 0x6D, 0x6F, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x31, 0x20, 0x20, 0x49, 0x4E,  
      0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30,  
      0x30, 0x30, 0x30, 0x5F, 0x31, 0x38, 0x33, 0x34, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43,  
      0x6F, 0x67, 0x32, 0x20, 0x20, 0x49, 0x4E, 0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F,  
      0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x31, 0x41, 0x33, 0x34, 0x20,  
      0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x30                                        
    ]);
    
    const packet2 = new Uint8Array([
      0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x73, 0x20, 0x72, 0x75, 0x6E, 0x2C, 0x20, 0x4D, 0x61, 0x69,  
      0x6E, 0x20, 0x6E, 0x6F, 0x77, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x69, 0x6E, 0x67, 0x21, 0x0D, 0x0A,  
      0x43, 0x6F, 0x67, 0x31, 0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x65,  
      0x77, 0x20, 0x43, 0x4F, 0x47, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0D, 0x0A, 0x43,  
      0x6F, 0x67, 0x32, 0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x65, 0x77,  
      0x20, 0x43, 0x4F, 0x47, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0D, 0x0A, 0x01, 0x00,  
      // COG1 80-byte debugger packet
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x00, 0xA1, 0x03, 0xF8, 0x01, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x85, 0x22, 0x40, 0x00, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x5F, 0x02, 0x00, 0x40, 0x5D, 0x1C, 0x00, 0x00, 0x4C, 0x18, 0x00, 0x00,
      0x00, 0x00, 0x08, 0x00, 0x80, 0xB2, 0xE6, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x40, 0x2F, 0x40, 0x2F,
      0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F,
      0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F,
      0x40, 0x2F, 0xA4, 0xB4, 0x5E, 0x8C, 0x47, 0x39, 0xC0, 0xE8, 0x09, 0xEB, 0x89, 0xED, 0xA7, 0xCD,
      0x83, 0x6A, 0xAC, 0x63, 0x4D, 0x77, 0xF3, 0xE7, 0xFE, 0x2F, 0x40, 0x2F, 0x0A, 0x04, 0x40, 0x2F,
      0xE2, 0x54, 0x47, 0xBA, 0x60, 0xB1, 0x4B, 0xF5, 0xF7, 0xF9, 0xBD, 0xCB, 0x2F, 0x74, 0x9F, 0x2F,
      0x31, 0x18, 0xA4, 0x62, 0x95, 0xD7, 0x44, 0xB5, 0x06, 0x6E, 0x4F, 0xD1, 0xE6, 0x51, 0x1D, 0x4B,
      0x28, 0x50, 0xCE, 0x20, 0x46, 0x94, 0xA3, 0xD1, 0x50, 0xE3, 0x49, 0xA2, 0x7D, 0xB1, 0xCE, 0x48,
      0xBD, 0xF1, 0x8A, 0xEF, 0xCE, 0xD7, 0x01, 0xBC, 0xB6, 0x78, 0xE3, 0xA5, 0xE6, 0x74, 0xE9, 0x60,
      0x55, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
    ]);

    const packet3 = new Uint8Array([
      // COG2 debugger packet 
      0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0E, 0x00, 0xA2, 0x03, 0xF8, 0x02, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x86, 0x23, 0x41, 0x00, 0xFF, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x60, 0x02, 0x00, 0x41, 0x5E, 0x1D, 0x00, 0x00, 0x4D, 0x19, 0x00, 0x00,
      0x00, 0x00, 0x09, 0x00, 0x81, 0xB3, 0xE7, 0x0F, 0x11, 0x00, 0x00, 0x00, 0x41, 0x30, 0x41, 0x30,
      0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30,
      0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30, 0x41, 0x30,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ]);

    const packet4 = new Uint8Array([
      // Post-debugger ASCII messages 
      0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x50, 0x6F, 0x73, 0x74, 0x2D, 0x64, 0x65, 0x62, 0x75, 0x67,
      0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x31, 0x0D, 0x0A,
      0x43, 0x6F, 0x67, 0x31, 0x20, 0x20, 0x50, 0x6F, 0x73, 0x74, 0x2D, 0x64, 0x65, 0x62, 0x75, 0x67,
      0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x32, 0x0D, 0x0A
    ]);

    // Feed all data to extractor
    feedDataAndExtract(packet1, "PACKET 1");
    feedDataAndExtract(packet2, "PACKET 2");  
    feedDataAndExtract(packet3, "PACKET 3 - COG2");
    feedDataAndExtract(packet4, "PACKET 4 - POST-DEBUG");
    
    console.log(`Extracted ${extractedMessages.length} messages total`);
    
    // === STEP 2: ROUTE ALL MESSAGES ===  
    console.log('\n--- STEP 2: MESSAGE ROUTING ---');
    
    // Add messages to router queue for processing
    extractedMessages.forEach((msg, i) => {
      const preview = new TextDecoder().decode(msg.data.slice(0, 20)).replace(/\r|\n/g, '');
      console.log(`Enqueuing message ${i+1}: ${msg.type} - "${preview}"`);
      routerQueue.enqueue(msg);
    });
    
    // Process all messages through the router
    let processed = 0;
    let maxAttempts = 10;
    let attempts = 0;
    
    while (routerQueue.getStats().currentSize > 0 && attempts < maxAttempts) {
      const processedThisRound = router.processMessages();
      processed += processedThisRound ? 1 : 0;
      attempts++;
      
      if (!processedThisRound) {
        // Give some time before trying again
        await new Promise(resolve => setTimeout(resolve, 10));
      }
    }
    
    console.log(`Processed ${processed} rounds, queue size: ${routerQueue.getStats().currentSize}`);
    
    // === STEP 3: VERIFY DEBUG LOGGER RECEIVED MESSAGES ===
    console.log('\n--- STEP 3: DEBUG LOGGER VERIFICATION ---');
    
    const debuggerMessages = mockDebugLogger.getDebuggerPackets();
    const cogLoggerMessages = mockDebugLogger.getCOGMessages();
    
    console.log(`Debug Logger received:`);
    console.log(`- COG Messages: ${cogLoggerMessages.length}`);
    console.log(`- Debugger Packets: ${debuggerMessages.length}`);
    
    // Detailed analysis of what Debug Logger received
    console.log('\n--- DEBUGGER PACKETS RECEIVED ---');
    debuggerMessages.forEach((msg, i) => {
      const cogId = msg.data[0];
      console.log(`${i+1}. DEBUGGER_80BYTE: COG ${cogId} (${msg.data.length} bytes)`);
    });
    
    console.log('\n--- COG MESSAGES RECEIVED ---');
    cogLoggerMessages.forEach((msg, i) => {
      const preview = new TextDecoder().decode(msg.data.slice(0, 30)).replace(/\r|\n/g, '');
      console.log(`${i+1}. COG_MESSAGE: "${preview}"`);
    });
    
    // === CRITICAL TESTS ===
    console.log('\n=== PIPELINE VERIFICATION ===');
    
    // Test 1: Both debugger packets should be extracted
    const extractedDebuggerPackets = extractedMessages.filter(m => m.type === MessageType.DEBUGGER_80BYTE);
    console.log(`âœ“ Extracted debugger packets: ${extractedDebuggerPackets.length} (should be 2)`);
    expect(extractedDebuggerPackets.length).toBe(2);
    
    // Test 2: Both packets should reach Debug Logger  
    console.log(`âœ“ Debug Logger received debugger packets: ${debuggerMessages.length} (should be 2)`);
    expect(debuggerMessages.length).toBe(2);
    
    // Test 3: Verify COG IDs are correct
    expect(debuggerMessages[0].data[0]).toBe(0x01); // COG 1
    expect(debuggerMessages[1].data[0]).toBe(0x02); // COG 2
    console.log(`âœ“ COG IDs correct: COG ${debuggerMessages[0].data[0]} and COG ${debuggerMessages[1].data[0]}`);
    
    // Test 4: System should recover and process ASCII messages after debugger packets
    const postDebugMessages = cogLoggerMessages.filter(m => {
      const text = new TextDecoder().decode(m.data);
      return text.includes('Post-debug message');
    });
    console.log(`âœ“ Post-debugger recovery: ${postDebugMessages.length} messages (should be 2)`);
    expect(postDebugMessages.length).toBe(2);
    
    console.log('\nðŸŽ‰ FULL PIPELINE TEST PASSED - Both COG1 and COG2 packets delivered to Debug Logger!');
  });
});