/** @format */

import { CircularBuffer } from '../src/classes/shared/circularBuffer';
import { MessageExtractor, MessageType, ExtractedMessage } from '../src/classes/shared/messageExtractor';
import { DynamicQueue } from '../src/classes/shared/dynamicQueue';

describe('Hardware Test Reproduction', () => {
  let buffer: CircularBuffer;
  let extractor: MessageExtractor;
  let outputQueue: DynamicQueue<ExtractedMessage>;
  let extractedMessages: ExtractedMessage[];

  beforeEach(() => {
    buffer = new CircularBuffer();
    outputQueue = new DynamicQueue<ExtractedMessage>(1000);
    extractor = new MessageExtractor(buffer, outputQueue);
    extractedMessages = [];
  });

  function feedDataAndExtract(data: Uint8Array, packetName: string): void {
    console.log(`\n=== FEEDING ${packetName}: ${data.length} bytes ===`);
    
    // Add data to buffer using the correct method
    const appended = buffer.appendAtTail(data);
    if (!appended) {
      console.error(`Failed to append ${data.length} bytes to buffer!`);
      return;
    }
    
    // Extract messages
    extractor.extractMessages();
    
    // Collect any new messages
    let message;
    while ((message = outputQueue.dequeue())) {
      extractedMessages.push(message);
      const preview = message.data.length > 0 ? new TextDecoder().decode(message.data.slice(0, Math.min(50, message.data.length))) : '';
      console.log(`EXTRACTED: ${message.type} - ${message.data.length} bytes - "${preview}"`);
    }
  }

  it('should reproduce exact hardware test sequence', () => {
    // Packet 1: 186 bytes (COG messages)
    const packet1 = new Uint8Array([
      0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x49, 0x4E, 0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30,  // Cog0  INIT $000
      0x5F, 0x30, 0x30, 0x30, 0x30, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x30, 0x30, 0x30,  // _0000 $0000_000
      0x20, 0x6C, 0x6F, 0x61, 0x64, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x49, 0x4E, 0x49,  //  load..Cog0  INI
      0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30, 0x30,  // T $0000_0F5C $00
      0x30, 0x30, 0x5F, 0x31, 0x43, 0x36, 0x38, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43, 0x6F,  // 00_1C68 jump..Co
      0x67, 0x30, 0x20, 0x20, 0x68, 0x69, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x64, 0x65, 0x62, 0x75,  // g0  hi from debu
      0x67, 0x20, 0x64, 0x65, 0x6D, 0x6F, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x31, 0x20, 0x20, 0x49, 0x4E,  // g demo..Cog1  IN
      0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30,  // IT $0000_0F5C $0
      0x30, 0x30, 0x30, 0x5F, 0x31, 0x38, 0x33, 0x34, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43,  // 000_1834 jump..C
      0x6F, 0x67, 0x32, 0x20, 0x20, 0x49, 0x4E, 0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F,  // og2  INIT $0000_
      0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x31, 0x41, 0x33, 0x34, 0x20,  // 0F5C $0000_1A34 
      0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x30                                        // jump..Cog0
    ]);
    
    // Packet 2: 372 bytes (more COG messages + binary data)
    const packet2 = new Uint8Array([
      0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x73, 0x20, 0x72, 0x75, 0x6E, 0x2C, 0x20, 0x4D, 0x61, 0x69,  //   Tasks run, Mai
      0x6E, 0x20, 0x6E, 0x6F, 0x77, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x69, 0x6E, 0x67, 0x21, 0x0D, 0x0A,  // n now looping!..
      0x43, 0x6F, 0x67, 0x31, 0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x65,  // Cog1  Task in ne
      0x77, 0x20, 0x43, 0x4F, 0x47, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0D, 0x0A, 0x43,  // w COG started..C
      0x6F, 0x67, 0x32, 0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x65, 0x77,  // og2  Task in new
      0x20, 0x43, 0x4F, 0x47, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0D, 0x0A, 0x01, 0x00,  //  COG started....
      // === CRITICAL: 80-byte binary packet starts here with 0x01 (COG 1) ===
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x00, 0xA1, 0x03, 0xF8, 0x01, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x85, 0x22, 0x40, 0x00, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x5F, 0x02, 0x00, 0x40, 0x5D, 0x1C, 0x00, 0x00, 0x4C, 0x18, 0x00, 0x00,
      0x00, 0x00, 0x08, 0x00, 0x80, 0xB2, 0xE6, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x40, 0x2F, 0x40, 0x2F,
      // === 80-byte packet continues ===
      0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F,
      0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F,
      0x40, 0x2F, 0xA4, 0xB4, 0x5E, 0x8C, 0x47, 0x39, 0xC0, 0xE8, 0x09, 0xEB, 0x89, 0xED, 0xA7, 0xCD,
      0x83, 0x6A, 0xAC, 0x63, 0x4D, 0x77, 0xF3, 0xE7, 0xFE, 0x2F, 0x40, 0x2F, 0x0A, 0x04, 0x40, 0x2F,
      0xE2, 0x54, 0x47, 0xBA, 0x60, 0xB1, 0x4B, 0xF5, 0xF7, 0xF9, 0xBD, 0xCB, 0x2F, 0x74, 0x9F, 0x2F,
      0x31, 0x18, 0xA4, 0x62, 0x95, 0xD7, 0x44, 0xB5, 0x06, 0x6E, 0x4F, 0xD1, 0xE6, 0x51, 0x1D, 0x4B,
      0x28, 0x50, 0xCE, 0x20, 0x46, 0x94, 0xA3, 0xD1, 0x50, 0xE3, 0x49, 0xA2, 0x7D, 0xB1, 0xCE, 0x48,
      0xBD, 0xF1, 0x8A, 0xEF, 0xCE, 0xD7, 0x01, 0xBC, 0xB6, 0x78, 0xE3, 0xA5, 0xE6, 0x74, 0xE9, 0x60,
      0x55, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
    ]);

    // Packet 3: 124 bytes (second 80-byte packet + padding)
    const packet3 = new Uint8Array([
      // === HYPOTHESIS: This should be COG 2 (0x02) + 79 bytes, but it's all zeros in console ===
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ]);

    // Packet 4: 54 bytes (more zeros - probably padding)
    const packet4 = new Uint8Array([
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ]);

    // Feed data in exact same order and sizes as hardware test
    feedDataAndExtract(packet1, "PACKET 1 (186 bytes)");
    feedDataAndExtract(packet2, "PACKET 2 (372 bytes)"); 
    feedDataAndExtract(packet3, "PACKET 3 (124 bytes)");
    feedDataAndExtract(packet4, "PACKET 4 (54 bytes)");

    console.log(`\n=== FINAL ANALYSIS ===`);
    console.log(`Total messages extracted: ${extractedMessages.length}`);
    
    // Expected based on visual inspection of hex dumps:
    // STRINGS (should be COG_MESSAGE):
    // - "Cog0  INIT $0000_0000 $0000_0000 load\r\n"
    // - "Cog0  INIT $0000_0F5C $0000_1C68 jump\r\n"  
    // - "Cog0  hi from debug demo\r\n"
    // - "Cog1  INIT $0000_0F5C $0000_1834 jump\r\n"
    // - "Cog2  INIT $0000_0F5C $0000_1A34 jump\r\n"
    // - "Cog0  Tasks run, Main now looping!\r\n"
    // - "Cog1  Task in new COG started\r\n"
    // - "Cog2  Task in new COG started\r\n"
    //
    // BINARY PACKETS (should be DEBUGGER_80BYTE):
    // - COG 1: 80 bytes starting with 0x01
    // - COG 2: 80 bytes starting with 0x02 (if it exists)
    
    const cogMessages = extractedMessages.filter(m => m.type === MessageType.COG_MESSAGE);
    const debuggerPackets = extractedMessages.filter(m => m.type === MessageType.DEBUGGER_80BYTE);
    const terminalOutput = extractedMessages.filter(m => m.type === MessageType.TERMINAL_OUTPUT);
    const systemInit = extractedMessages.filter(m => m.type === MessageType.P2_SYSTEM_INIT);
    
    console.log(`COG_MESSAGE: ${cogMessages.length} (expected: 8 strings)`);
    console.log(`DEBUGGER_80BYTE: ${debuggerPackets.length} (expected: 1-2 packets)`); 
    console.log(`TERMINAL_OUTPUT: ${terminalOutput.length} (expected: 0 - everything should be classified as COG_MESSAGE)`);
    console.log(`P2_SYSTEM_INIT: ${systemInit.length}`);
    
    // Print what we actually got for debugging
    console.log('\n=== ACTUAL EXTRACTIONS ===');
    extractedMessages.forEach((msg, i) => {
      const preview = new TextDecoder().decode(msg.data.slice(0, 30));
      console.log(`${i+1}. ${msg.type}: "${preview}..." (${msg.data.length} bytes)`);
    });
    
    // Verify we get the expected data structure
    expect(cogMessages.length).toBe(8); // Should have exactly 8 COG message strings
    expect(terminalOutput.length).toBe(0); // Should have ZERO terminal output - everything should be COG_MESSAGE  
    expect(debuggerPackets.length).toBeGreaterThanOrEqual(1); // Should have at least one 80-byte packet
    
    // Check that first 80-byte packet is COG 1 (0x01), not COG 0 (0x00)
    if (debuggerPackets.length > 0) {
      expect(debuggerPackets[0].data[0]).toBe(0x01); // Should be COG 1, not COG 0
    }
  });
});