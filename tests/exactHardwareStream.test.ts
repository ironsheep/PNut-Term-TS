/**
 * EXACT Hardware Stream Test
 * Reproduces the EXACT byte sequence from hardware test console log
 */

import { CircularBuffer } from '../src/classes/shared/circularBuffer';
import { MessageExtractor, MessageType, ExtractedMessage } from '../src/classes/shared/messageExtractor';
import { DynamicQueue } from '../src/classes/shared/dynamicQueue';

describe('Exact Hardware Stream Test', () => {
  it('should extract both COG1 and COG2 packets from EXACT hardware stream', () => {
    const buffer = new CircularBuffer(8192);
    const outputQueue = new DynamicQueue<ExtractedMessage>(1000);
    const extractor = new MessageExtractor(buffer, outputQueue);
    
    // These are the EXACT bytes from console log in 4 chunks
    // Chunk 1: 124 bytes
    const chunk1 = new Uint8Array([
      0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x49, 0x4E, 0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30,
      0x5F, 0x30, 0x30, 0x30, 0x30, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x30, 0x30, 0x30,
      0x20, 0x6C, 0x6F, 0x61, 0x64, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x49, 0x4E, 0x49,
      0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30, 0x30,
      0x30, 0x30, 0x5F, 0x31, 0x43, 0x36, 0x38, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43, 0x6F,
      0x67, 0x30, 0x20, 0x20, 0x68, 0x69, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x64, 0x65, 0x62, 0x75,
      0x67, 0x20, 0x64, 0x65, 0x6D, 0x6F, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x31, 0x20, 0x20, 0x49, 0x4E,
      0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35
    ]);

    // Chunk 2: 372 bytes  
    const chunk2 = new Uint8Array([
      0x43, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x31, 0x38, 0x33, 0x34, 0x20, 0x6A, 0x75, 0x6D,
      0x70, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x32, 0x20, 0x20, 0x49, 0x4E, 0x49, 0x54, 0x20, 0x24, 0x30,
      0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x31,
      0x41, 0x33, 0x34, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x30, 0x20, 0x20,
      0x54, 0x61, 0x73, 0x6B, 0x73, 0x20, 0x72, 0x75, 0x6E, 0x2C, 0x20, 0x4D, 0x61, 0x69, 0x6E, 0x20,
      0x6E, 0x6F, 0x77, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x69, 0x6E, 0x67, 0x21, 0x0D, 0x0A, 0x43, 0x6F,
      0x67, 0x31, 0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x65, 0x77, 0x20,
      0x43, 0x4F, 0x47, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0D, 0x0A, 0x43, 0x6F, 0x67,
      0x32, 0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x43,
      0x4F, 0x47, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0D, 0x0A,
      // COG1 packet starts here at offset 0x9A (154)
      0x01, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x0E, 0x00, 0xA1, 0x03, 0xF8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x85, 0x22, 0x40, 0x00, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x5F, 0x02, 0x00, 0x40, 0x5D, 0x1C, 0x00, 0x00, 0x4C, 0x18, 0x00, 0x00,
      0x00, 0x00, 0x08, 0x00, 0x80, 0xB2, 0xE6, 0x0E, 0x10, 0x00, 0x00, 0x00,
      // COG2 packet starts here - IMMEDIATELY after COG1, at offset 0xEA (234) 
      0x02, 0x00, 0x00, 0x00, // COG2 ID
      0x02, 0x00, 0x00, 0x00, // More COG2 data...
      0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F,
      0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F,
      0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0xA4, 0xB4, 0x5E, 0x8C, 0x47, 0x39, 0xC0, 0xE8,
      0x09, 0xEB, 0x89, 0xED, 0xA7, 0xCD, 0x83, 0x6A, 0xAC, 0x63, 0x4D, 0x77, 0xF3, 0xE7, 0xFE, 0x2F,
      0x40, 0x2F, 0x0A, 0x04, 0x40, 0x2F, 0xE2, 0x54, 0x47, 0xBA, 0x60, 0xB1, 0x4B, 0xF5, 0xF7, 0xF9,
      0xBD, 0xCB, 0x2F, 0x74, 0x9F, 0x2F, 0x31, 0x18, 0xA4, 0x62, 0x95, 0xD7, 0x44, 0xB5, 0x06, 0x6E,
      0x4F, 0xD1, 0xE6, 0x51, 0x1D, 0x4B, 0x28, 0x50, 0xCE, 0x20, 0x46, 0x94, 0xA3, 0xD1, 0x50, 0xE3,
      0x49, 0xA2, 0x7D, 0xB1, 0xCE, 0x48, 0xBD, 0xF1, 0x8A, 0xEF, 0xCE, 0xD7, 0x01, 0xBC, 0xB6, 0x78,
      0xE3, 0xA5, 0xE6, 0x74, 0xE9, 0x60, 0x55, 0x77, 0x00, 0x00, 0x00, 0x00
    ]);

    // Chunk 3: 186 bytes (all zeros)
    const chunk3 = new Uint8Array(186).fill(0x00);

    // Chunk 4: 54 bytes (all zeros)
    const chunk4 = new Uint8Array(54).fill(0x00);

    // Feed chunks to buffer exactly as hardware sends them
    console.log('\n=== EXACT HARDWARE STREAM TEST ===');
    console.log('Chunk 1: 124 bytes');
    buffer.appendAtTail(chunk1);
    
    console.log('Chunk 2: 372 bytes (contains both COG1 at 0x9A and COG2 at 0xEA)');
    buffer.appendAtTail(chunk2);
    
    console.log('Chunk 3: 186 bytes (zeros)');
    buffer.appendAtTail(chunk3);
    
    console.log('Chunk 4: 54 bytes (zeros)');
    buffer.appendAtTail(chunk4);

    // Process all messages through extractor
    const result = extractor.extractBatch();
    console.log(`Extracted ${result.messages.length} messages in batch, hasMore: ${result.hasMore}`);
    
    // Get all messages
    const messages = result.messages;
    messages.forEach(msg => {
      if (msg.type === MessageType.DEBUGGER_80BYTE) {
        const cogId = msg.data[0];
        console.log(`Extracted: DEBUGGER_80BYTE for COG ${cogId}`);
      }
    });

    // Count message types
    const cogMessages = messages.filter(m => m.type === MessageType.COG_MESSAGE);
    const debuggerPackets = messages.filter(m => m.type === MessageType.DEBUGGER_80BYTE);
    
    console.log(`\nResults:`);
    console.log(`- COG Messages: ${cogMessages.length} (expected: 8)`);
    console.log(`- Debugger Packets: ${debuggerPackets.length} (expected: 2)`);
    
    if (debuggerPackets.length > 0) {
      console.log(`- COG1 ID: 0x${debuggerPackets[0].data[0].toString(16).padStart(2, '0')}`);
      if (debuggerPackets.length > 1) {
        console.log(`- COG2 ID: 0x${debuggerPackets[1].data[0].toString(16).padStart(2, '0')}`);
      } else {
        console.log('- COG2: NOT EXTRACTED!');
      }
    }

    // CRITICAL TESTS
    expect(cogMessages.length).toBe(8);
    expect(debuggerPackets.length).toBe(2); // THIS IS THE KEY TEST
    expect(debuggerPackets[0].data[0]).toBe(0x01); // COG1
    expect(debuggerPackets[1].data[0]).toBe(0x02); // COG2
  });
});