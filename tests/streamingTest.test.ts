/** @format */

import { SerialMessageProcessor } from '../src/classes/shared/serialMessageProcessor';
import { MessageType, ExtractedMessage } from '../src/classes/shared/messageExtractor';

describe('Streaming Test - Full System Integration', () => {
  let processor: SerialMessageProcessor;
  let capturedMessages: { type: MessageType; data: Uint8Array }[] = [];

  beforeEach(() => {
    capturedMessages = [];
    processor = new SerialMessageProcessor();
    
    // Mock destination to capture all messages
    const mockDestination = {
      name: 'TestDestination',
      handler: (message: ExtractedMessage) => {
        capturedMessages.push({
          type: message.type,
          data: new Uint8Array(message.data) // Copy the data
        });
      }
    };
    
    // Register mock destination for all message types
    processor.registerDestination(MessageType.COG_MESSAGE, mockDestination);
    processor.registerDestination(MessageType.DEBUGGER_80BYTE, mockDestination);
    processor.registerDestination(MessageType.TERMINAL_OUTPUT, mockDestination);
    processor.registerDestination(MessageType.DB_PACKET, mockDestination);
    processor.registerDestination(MessageType.BACKTICK_WINDOW, mockDestination);
    processor.registerDestination(MessageType.P2_SYSTEM_INIT, mockDestination);
    processor.registerDestination(MessageType.INVALID_COG, mockDestination);
    processor.registerDestination(MessageType.INCOMPLETE_DEBUG, mockDestination);
    
    processor.start();
  });

  afterEach(async () => {
    await processor.stop();
  });

  it('should handle cross-packet messages using full system stack', async () => {
    // Same data as hardware test - feed through the FULL SYSTEM STACK
    const packet1 = new Uint8Array([
      0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x49, 0x4E, 0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30,
      0x5F, 0x30, 0x30, 0x30, 0x30, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x30, 0x30, 0x30,
      0x20, 0x6C, 0x6F, 0x61, 0x64, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x49, 0x4E, 0x49,
      0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30, 0x30,
      0x30, 0x30, 0x5F, 0x31, 0x43, 0x36, 0x38, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43, 0x6F,
      0x67, 0x30, 0x20, 0x20, 0x68, 0x69, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x64, 0x65, 0x62, 0x75,
      0x67, 0x20, 0x64, 0x65, 0x6D, 0x6F, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x31, 0x20, 0x20, 0x49, 0x4E,
      0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30,
      0x30, 0x30, 0x30, 0x5F, 0x31, 0x38, 0x33, 0x34, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43,
      0x6F, 0x67, 0x32, 0x20, 0x20, 0x49, 0x4E, 0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F,
      0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x31, 0x41, 0x33, 0x34, 0x20,
      0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x30
    ]);
    
    const packet2 = new Uint8Array([
      0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x73, 0x20, 0x72, 0x75, 0x6E, 0x2C, 0x20, 0x4D, 0x61, 0x69,
      0x6E, 0x20, 0x6E, 0x6F, 0x77, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x69, 0x6E, 0x67, 0x21, 0x0D, 0x0A,
      0x43, 0x6F, 0x67, 0x31, 0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x65,
      0x77, 0x20, 0x43, 0x4F, 0x47, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0D, 0x0A, 0x43,
      0x6F, 0x67, 0x32, 0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x65, 0x77,
      0x20, 0x43, 0x4F, 0x47, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0D, 0x0A, 0x01, 0x00,
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x00, 0xA1, 0x03, 0xF8, 0x01, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x85, 0x22, 0x40, 0x00, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x5F, 0x02, 0x00, 0x40, 0x5D, 0x1C, 0x00, 0x00, 0x4C, 0x18, 0x00, 0x00,
      0x00, 0x00, 0x08, 0x00, 0x80, 0xB2, 0xE6, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x40, 0x2F, 0x40, 0x2F,
      0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F,
      0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F,
      0x40, 0x2F, 0xA4, 0xB4, 0x5E, 0x8C, 0x47, 0x39, 0xC0, 0xE8, 0x09, 0xEB, 0x89, 0xED, 0xA7, 0xCD,
      0x83, 0x6A, 0xAC, 0x63, 0x4D, 0x77, 0xF3, 0xE7, 0xFE, 0x2F, 0x40, 0x2F, 0x0A, 0x04, 0x40, 0x2F,
      0xE2, 0x54, 0x47, 0xBA, 0x60, 0xB1, 0x4B, 0xF5, 0xF7, 0xF9, 0xBD, 0xCB, 0x2F, 0x74, 0x9F, 0x2F,
      0x31, 0x18, 0xA4, 0x62, 0x95, 0xD7, 0x44, 0xB5, 0x06, 0x6E, 0x4F, 0xD1, 0xE6, 0x51, 0x1D, 0x4B,
      0x28, 0x50, 0xCE, 0x20, 0x46, 0x94, 0xA3, 0xD1, 0x50, 0xE3, 0x49, 0xA2, 0x7D, 0xB1, 0xCE, 0x48,
      0xBD, 0xF1, 0x8A, 0xEF, 0xCE, 0xD7, 0x01, 0xBC, 0xB6, 0x78, 0xE3, 0xA5, 0xE6, 0x74, 0xE9, 0x60,
      0x55, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
    ]);

    console.log('=== FEEDING DATA THROUGH FULL SYSTEM STACK ===');
    
    // Feed data through SerialReceiver → CircularBuffer → MessageExtractor → MessageRouter
    processor.simulateData(packet1);
    processor.simulateData(packet2);
    
    // Wait for processing to complete
    const processingComplete = await processor.waitForIdle(5000);
    expect(processingComplete).toBe(true);
    
    console.log(`Total messages captured: ${capturedMessages.length}`);
    capturedMessages.forEach((msg, index) => {
      const preview = new TextDecoder().decode(msg.data.slice(0, 30));
      console.log(`CAPTURED: ${msg.type} - ${msg.data.length} bytes - "${preview}..."`);
    });
    
    const cogMessages = capturedMessages.filter(m => m.type === MessageType.COG_MESSAGE);
    const debuggerPackets = capturedMessages.filter(m => m.type === MessageType.DEBUGGER_80BYTE);
    const terminalOutput = capturedMessages.filter(m => m.type === MessageType.TERMINAL_OUTPUT);
    
    console.log(`\nRESULTS:`);
    console.log(`COG_MESSAGE: ${cogMessages.length} (should handle cross-packet boundary)`);
    console.log(`DEBUGGER_80BYTE: ${debuggerPackets.length}`);
    console.log(`TERMINAL_OUTPUT: ${terminalOutput.length}`);
    
    // BYTE-PERFECT VALIDATION: Every byte must be accounted for
    const totalInputBytes = packet1.length + packet2.length;
    const totalExtractedBytes = capturedMessages.reduce((sum, msg) => sum + msg.data.length, 0);
    
    console.log(`\nBYTE ACCOUNTING:`);
    console.log(`Total input bytes: ${totalInputBytes}`);
    console.log(`Total extracted bytes: ${totalExtractedBytes}`);
    console.log(`Missing bytes: ${totalInputBytes - totalExtractedBytes}`);
    
    // CRITICAL: Every single input byte MUST be extracted
    expect(totalExtractedBytes).toBe(totalInputBytes);
    
    // CRITICAL: Each COG message MUST end with complete CRLF (0x0D 0x0A)
    cogMessages.forEach((msg, index) => {
      const lastTwoBytes = [msg.data[msg.data.length - 2], msg.data[msg.data.length - 1]];
      console.log(`COG message ${index}: last 2 bytes = [0x${lastTwoBytes[0]?.toString(16)}, 0x${lastTwoBytes[1]?.toString(16)}]`);
      expect(msg.data[msg.data.length - 2]).toBe(0x0D); // Must end with CR
      expect(msg.data[msg.data.length - 1]).toBe(0x0A); // Must end with LF
    });
    
    // CRITICAL: Debugger packet MUST be detected (not fall to terminal output)
    expect(debuggerPackets.length).toBe(1);
    expect(terminalOutput.length).toBe(0); // Should be ZERO if classification works
    
    // CRITICAL: Debugger packet MUST start with binary COG ID (0x01), NOT orphaned LF
    if (debuggerPackets.length > 0) {
      const firstBytes = Array.from(debuggerPackets[0].data.slice(0, 4));
      console.log(`Debugger packet starts with: [${firstBytes.map(b => '0x' + b.toString(16)).join(', ')}]`);
      expect(debuggerPackets[0].data[0]).toBe(0x01); // Must start with COG ID 1, not 0x0A
      expect(debuggerPackets[0].data.length).toBe(80); // Must be exactly 80 bytes
    }
  });
});