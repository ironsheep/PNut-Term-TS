/**
 * EXACT Hardware Routing Test
 * Uses the EXACT chunk boundaries from hardware console log
 * Tests full pipeline: extraction -> routing -> Debug Logger
 */

import { CircularBuffer } from '../src/classes/shared/circularBuffer';
import { MessageExtractor, MessageType, ExtractedMessage } from '../src/classes/shared/messageExtractor';
import { DynamicQueue } from '../src/classes/shared/dynamicQueue';
import { MessageRouter, RouteDestination } from '../src/classes/shared/messageRouter';

// Mock Debug Logger to verify end-to-end delivery
class MockDebugLogger implements RouteDestination {
  public name = 'MockDebugLogger';
  private debuggerPackets: any[] = [];
  private cogMessages: any[] = [];
  
  public handler = (message: any): void => {
    // Handle both ExtractedMessage and PooledMessage
    const actualMessage = 'poolId' in message ? message : message;
    
    if (actualMessage.type === MessageType.DEBUGGER_80BYTE) {
      this.debuggerPackets.push(actualMessage);
      console.log(`[DEBUG LOGGER] Received DEBUGGER_80BYTE for COG ${actualMessage.data[0]}`);
    } else if (actualMessage.type === MessageType.COG_MESSAGE) {
      this.cogMessages.push(actualMessage);
      const text = new TextDecoder().decode(actualMessage.data).trim();
      console.log(`[DEBUG LOGGER] Received COG_MESSAGE: "${text.substring(0, 40)}..."`);
    }
  };
  
  public getDebuggerPackets() { return this.debuggerPackets; }
  public getCOGMessages() { return this.cogMessages; }
}

describe('Exact Hardware Routing Test', () => {
  it('should route both COG1 and COG2 packets to Debug Logger using EXACT hardware chunks', () => {
    // Setup full pipeline
    const buffer = new CircularBuffer(8192);
    const extractorQueue = new DynamicQueue<ExtractedMessage>(1000);
    const extractor = new MessageExtractor(buffer, extractorQueue);
    const routerQueue = new DynamicQueue<ExtractedMessage>(1000);
    const router = new MessageRouter(routerQueue);
    const mockDebugLogger = new MockDebugLogger();
    
    // Register Debug Logger for both message types
    router.registerDestination(MessageType.DEBUGGER_80BYTE, mockDebugLogger);
    router.registerDestination(MessageType.COG_MESSAGE, mockDebugLogger);
    
    console.log('\n=== EXACT HARDWARE ROUTING TEST ===');
    console.log('Using EXACT chunk boundaries from console log');
    
    // EXACT Chunk 1: 124 bytes (from console: [SERIAL RX] Received 124 bytes)
    const chunk1 = new Uint8Array([
      0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x49, 0x4E, 0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30,
      0x5F, 0x30, 0x30, 0x30, 0x30, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x30, 0x30, 0x30,
      0x20, 0x6C, 0x6F, 0x61, 0x64, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x30, 0x20, 0x20, 0x49, 0x4E, 0x49,
      0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30, 0x30,
      0x30, 0x30, 0x5F, 0x31, 0x43, 0x36, 0x38, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43, 0x6F,
      0x67, 0x30, 0x20, 0x20, 0x68, 0x69, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x64, 0x65, 0x62, 0x75,
      0x67, 0x20, 0x64, 0x65, 0x6D, 0x6F, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x31, 0x20, 0x20, 0x49, 0x4E,
      0x49, 0x54, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35
    ]);

    // EXACT Chunk 2: 372 bytes (from console: [SERIAL RX] Received 372 bytes)
    // This contains the rest of COG messages, COG1 debugger packet, AND COG2 debugger packet!
    const chunk2 = new Uint8Array([
      0x43, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x31, 0x38, 0x33, 0x34, 0x20, 0x6A, 0x75, 0x6D,
      0x70, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x32, 0x20, 0x20, 0x49, 0x4E, 0x49, 0x54, 0x20, 0x24, 0x30,
      0x30, 0x30, 0x30, 0x5F, 0x30, 0x46, 0x35, 0x43, 0x20, 0x24, 0x30, 0x30, 0x30, 0x30, 0x5F, 0x31,
      0x41, 0x33, 0x34, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x0D, 0x0A, 0x43, 0x6F, 0x67, 0x30, 0x20, 0x20,
      0x54, 0x61, 0x73, 0x6B, 0x73, 0x20, 0x72, 0x75, 0x6E, 0x2C, 0x20, 0x4D, 0x61, 0x69, 0x6E, 0x20,
      0x6E, 0x6F, 0x77, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x69, 0x6E, 0x67, 0x21, 0x0D, 0x0A, 0x43, 0x6F,
      0x67, 0x31, 0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x65, 0x77, 0x20,
      0x43, 0x4F, 0x47, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0D, 0x0A, 0x43, 0x6F, 0x67,
      0x32, 0x20, 0x20, 0x54, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x6E, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x43,
      0x4F, 0x47, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x0D, 0x0A,
      // COG1 debugger packet starts at offset 154 (0x9A)
      0x01, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x0E, 0x00, 0xA1, 0x03, 0xF8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x85, 0x22, 0x40, 0x00, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x5F, 0x02, 0x00, 0x40, 0x5D, 0x1C, 0x00, 0x00, 0x4C, 0x18, 0x00, 0x00,
      0x00, 0x00, 0x08, 0x00, 0x80, 0xB2, 0xE6, 0x0E, 0x10, 0x00, 0x00, 0x00,
      // COG2 debugger packet starts IMMEDIATELY after COG1 at offset 234 (0xEA)
      0x02, 0x00, 0x00, 0x00, // <-- THIS IS COG2!
      0x02, 0x00, 0x00, 0x00, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F,
      0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F,
      0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0x40, 0x2F, 0xA4, 0xB4, 0x5E, 0x8C,
      0x47, 0x39, 0xC0, 0xE8, 0x09, 0xEB, 0x89, 0xED, 0xA7, 0xCD, 0x83, 0x6A, 0xAC, 0x63, 0x4D, 0x77,
      0xF3, 0xE7, 0xFE, 0x2F, 0x40, 0x2F, 0x0A, 0x04, 0x40, 0x2F, 0xE2, 0x54, 0x47, 0xBA, 0x60, 0xB1,
      0x4B, 0xF5, 0xF7, 0xF9, 0xBD, 0xCB, 0x2F, 0x74, 0x9F, 0x2F, 0x31, 0x18, 0xA4, 0x62, 0x95, 0xD7,
      0x44, 0xB5, 0x06, 0x6E, 0x4F, 0xD1, 0xE6, 0x51, 0x1D, 0x4B, 0x28, 0x50, 0xCE, 0x20, 0x46, 0x94,
      0xA3, 0xD1, 0x50, 0xE3, 0x49, 0xA2, 0x7D, 0xB1, 0xCE, 0x48, 0xBD, 0xF1, 0x8A, 0xEF, 0xCE, 0xD7,
      0x01, 0xBC, 0xB6, 0x78, 0xE3, 0xA5, 0xE6, 0x74, 0xE9, 0x60, 0x55, 0x77, 0x00, 0x00, 0x00, 0x00
    ]);

    // EXACT Chunk 3: 186 bytes of zeros (from console: [SERIAL RX] Received 186 bytes)
    const chunk3 = new Uint8Array(186).fill(0x00);

    // EXACT Chunk 4: 54 bytes of zeros (from console: [SERIAL RX] Received 54 bytes)
    const chunk4 = new Uint8Array(54).fill(0x00);

    // Simulate EXACT hardware data arrival pattern
    console.log('\n--- SIMULATING HARDWARE DATA ARRIVAL ---');
    
    // Chunk 1 arrives
    console.log('Hardware sends chunk 1: 124 bytes');
    buffer.appendAtTail(chunk1);
    let result = extractor.extractBatch();
    console.log(`After chunk 1: Extracted ${result.messages.length} messages`);
    result.messages.forEach(msg => routerQueue.enqueue(msg));
    
    // Chunk 2 arrives (THIS CONTAINS BOTH DEBUGGER PACKETS!)
    console.log('\nHardware sends chunk 2: 372 bytes (contains COG1 at 154, COG2 at 234)');
    buffer.appendAtTail(chunk2);
    result = extractor.extractBatch();
    console.log(`After chunk 2: Extracted ${result.messages.length} messages`);
    result.messages.forEach(msg => routerQueue.enqueue(msg));
    
    // Look specifically for debugger packets
    const debuggerInChunk2 = result.messages.filter(m => m.type === MessageType.DEBUGGER_80BYTE);
    console.log(`CRITICAL: Found ${debuggerInChunk2.length} debugger packets in chunk 2`);
    debuggerInChunk2.forEach(pkt => {
      console.log(`  - COG ${pkt.data[0]} debugger packet`);
    });
    
    // Chunk 3 arrives
    console.log('\nHardware sends chunk 3: 186 bytes (zeros)');
    buffer.appendAtTail(chunk3);
    result = extractor.extractBatch();
    console.log(`After chunk 3: Extracted ${result.messages.length} messages`);
    result.messages.forEach(msg => routerQueue.enqueue(msg));
    
    // Chunk 4 arrives
    console.log('\nHardware sends chunk 4: 54 bytes (zeros)');
    buffer.appendAtTail(chunk4);
    result = extractor.extractBatch();
    console.log(`After chunk 4: Extracted ${result.messages.length} messages`);
    result.messages.forEach(msg => routerQueue.enqueue(msg));
    
    // Process routing queue
    console.log('\n--- ROUTING MESSAGES TO DEBUG LOGGER ---');
    // Move messages from extractor queue to router queue
    while (!routerQueue.isEmpty()) {
      const msg = routerQueue.dequeue();
      if (msg) {
        router.getInputQueue().enqueue(msg);
      }
    }
    // Process the router queue
    const routedCount = router.processMessagesSync();
    console.log(`Routed ${routedCount} messages to destinations`);
    
    // Check what Debug Logger received
    console.log('\n--- DEBUG LOGGER FINAL RESULTS ---');
    const debuggerPackets = mockDebugLogger.getDebuggerPackets();
    const cogMessages = mockDebugLogger.getCOGMessages();
    
    console.log(`Debug Logger received:`);
    console.log(`- COG Messages: ${cogMessages.length}`);
    console.log(`- Debugger Packets: ${debuggerPackets.length}`);
    
    if (debuggerPackets.length > 0) {
      debuggerPackets.forEach((pkt, i) => {
        console.log(`  ${i+1}. COG ${pkt.data[0]} (0x${pkt.data[0].toString(16).padStart(2, '0')})`);
      });
    }
    
    // CRITICAL ASSERTIONS
    console.log('\n=== CRITICAL TEST RESULTS ===');
    if (debuggerPackets.length === 2) {
      console.log('✅ PASS: Both debugger packets delivered to Debug Logger');
    } else {
      console.log(`❌ FAIL: Only ${debuggerPackets.length} debugger packet(s) delivered (expected 2)`);
    }
    
    expect(cogMessages.length).toBeGreaterThanOrEqual(8);
    expect(debuggerPackets.length).toBe(2); // THIS IS THE KEY TEST
    expect(debuggerPackets[0].data[0]).toBe(0x01); // COG1
    expect(debuggerPackets[1].data[0]).toBe(0x02); // COG2
  });
});