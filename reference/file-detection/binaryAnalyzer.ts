/**
 * Binary Analysis Utilities for PNut-TS compiled binaries
 *
 * This module provides tools to analyze .bin/.binf files generated by PNut-TS
 * and determine their compilation characteristics, particularly debug mode detection.
 */

import * as fs from 'fs';
import * as path from 'path';

/**
 * Result interface for binary analysis
 */
export interface BinaryAnalysisResult {
  /** True if binary was compiled with debug mode enabled */
  hasDebugger: boolean;
  /** True if binary contains flash loader (is .binf file) */
  hasFlashLoader: boolean;
  /** True if binary is PASM2 mode (no interpreter) */
  isPasm2Mode: boolean;
  /** Total binary size in bytes */
  binarySize: number;
  /** Estimated application size (excluding debugger/interpreter/flash loader) */
  applicationSize: number;
  /** Binary layout components detected */
  components: string[];
}

/**
 * Known signatures for different binary components
 */
const SIGNATURES = {
  // First 16 bytes of Spin2_debugger.obj (v43)
  DEBUGGER_V43: new Uint8Array([0x50, 0xf8, 0x08, 0xfc, 0x51, 0x04, 0x08, 0xfc,
                                0x41, 0xa2, 0x60, 0xfd, 0x51, 0x6a, 0x10, 0xfc]),

  // Known interpreter signatures (first few bytes of Spin2_interpreter.obj)
  INTERPRETER_V43: new Uint8Array([0x00, 0x1a, 0x60, 0xfd, 0x1f, 0x18, 0x60, 0xfd]),

  // Flash loader signature pattern (first bytes of flash_loader.obj subset)
  FLASH_LOADER: new Uint8Array([0x00, 0x00, 0x00, 0x00]) // Placeholder - needs actual signature
};

/**
 * Fixed sizes of known components (from documentation and analysis)
 * Note: Debugger has 16KB reserved space but actual debugger binary is ~2.9KB
 */
const COMPONENT_SIZES = {
  DEBUGGER_RESERVED_SIZE: 0x4000,   // 16KB reserved debugger space in memory
  DEBUGGER_BINARY_SIZE: 2932,       // Actual Spin2_debugger.obj file size
  FLASH_LOADER_SIZE: 0x0400,        // 1KB fixed flash loader section
  FLASH_APP_OFFSET: 0x0400          // Application starts at 1KB in flash files
};

/**
 * Analyzes a PNut-TS compiled binary file to detect compilation characteristics
 *
 * @param binaryPath Path to .bin or .binf file
 * @returns Analysis results including debug mode detection
 */
export function analyzeBinary(binaryPath: string): BinaryAnalysisResult {
  if (!fs.existsSync(binaryPath)) {
    throw new Error(`Binary file not found: ${binaryPath}`);
  }

  const binaryData = fs.readFileSync(binaryPath);
  const binarySize = binaryData.length;
  const isFlashFile = path.extname(binaryPath).toLowerCase() === '.binf';

  const result: BinaryAnalysisResult = {
    hasDebugger: false,
    hasFlashLoader: isFlashFile,
    isPasm2Mode: false,
    binarySize,
    applicationSize: binarySize,
    components: []
  };

  // Check for flash loader (only relevant for .binf files)
  let analysisOffset = 0;
  if (isFlashFile) {
    result.components.push('Flash Loader (1KB)');
    analysisOffset = COMPONENT_SIZES.FLASH_APP_OFFSET;
    result.applicationSize = binarySize - COMPONENT_SIZES.FLASH_LOADER_SIZE;
  }

  // Check for debugger signature at analysis offset
  if (binarySize >= analysisOffset + SIGNATURES.DEBUGGER_V43.length) {
    const headerBytes = binaryData.subarray(analysisOffset, analysisOffset + SIGNATURES.DEBUGGER_V43.length);

    if (arraysEqual(headerBytes, SIGNATURES.DEBUGGER_V43)) {
      result.hasDebugger = true;
      result.components.push('Debugger + Debug Data');

      // For debug binaries, we can't easily calculate exact application size
      // because debug data size varies. The binary contains debugger + debug data + application
      // We'll provide an estimate by subtracting the minimum debugger overhead
      result.applicationSize = binarySize - COMPONENT_SIZES.DEBUGGER_BINARY_SIZE - (isFlashFile ? COMPONENT_SIZES.FLASH_LOADER_SIZE : 0);

      // Mark that this is an estimate
      result.components.push('Application (size estimated)');

      // Don't advance analysisOffset for further analysis since debug data size varies
      return result; // Early return for debug binaries
    }
  }

  // Check for interpreter presence (indicates SPIN2 mode vs PASM2 mode)
  // In SPIN2 mode, interpreter follows debugger (if present) or starts at beginning
  if (binarySize >= analysisOffset + SIGNATURES.INTERPRETER_V43.length) {
    const interpreterCheckOffset = result.hasDebugger ?
      findInterpreterAfterDebugger(binaryData, analysisOffset) : analysisOffset;

    if (interpreterCheckOffset !== -1) {
      const interpreterBytes = binaryData.subarray(interpreterCheckOffset,
        interpreterCheckOffset + SIGNATURES.INTERPRETER_V43.length);

      if (arraysEqual(interpreterBytes, SIGNATURES.INTERPRETER_V43)) {
        result.components.push('SPIN2 Interpreter');
        result.isPasm2Mode = false;
      } else {
        result.isPasm2Mode = true;
        result.components.push('PASM2 Code (no interpreter)');
      }
    }
  }

  return result;
}

/**
 * Quick check to determine if a binary was compiled with debug mode
 *
 * @param binaryPath Path to .bin or .binf file
 * @returns True if debug mode was used during compilation
 */
export function isDebugBinary(binaryPath: string): boolean {
  try {
    const result = analyzeBinary(binaryPath);
    return result.hasDebugger;
  } catch (error) {
    return false;
  }
}

/**
 * Searches for interpreter signature after debugger section
 * This handles the variable-size debug data that follows the fixed debugger
 */
function findInterpreterAfterDebugger(binaryData: Uint8Array, startOffset: number): number {
  // Search within a reasonable range after debugger for interpreter signature
  const maxSearchRange = 1024; // Debug data shouldn't be too large
  const endOffset = Math.min(startOffset + maxSearchRange, binaryData.length - SIGNATURES.INTERPRETER_V43.length);

  for (let offset = startOffset; offset < endOffset; offset += 4) { // LONG-aligned search
    const bytes = binaryData.subarray(offset, offset + SIGNATURES.INTERPRETER_V43.length);
    if (arraysEqual(bytes, SIGNATURES.INTERPRETER_V43)) {
      return offset;
    }
  }
  return -1;
}

/**
 * Compares two Uint8Array objects for equality
 */
function arraysEqual(a: Uint8Array, b: Uint8Array): boolean {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

/**
 * Provides a human-readable summary of binary analysis
 */
export function formatAnalysisResult(result: BinaryAnalysisResult): string {
  const lines = [
    `Binary Analysis Results:`,
    `  Total Size: ${result.binarySize} bytes`,
    `  Debug Mode: ${result.hasDebugger ? 'YES' : 'NO'}`,
    `  Flash Mode: ${result.hasFlashLoader ? 'YES (.binf)' : 'NO (.bin)'}`,
    `  Mode: ${result.isPasm2Mode ? 'PASM2' : 'SPIN2'}`,
    `  Application Size: ${result.applicationSize} bytes`,
    `  Components: ${result.components.join(', ')}`
  ];
  return lines.join('\n');
}

/**
 * CLI utility function for standalone binary analysis
 */
export function analyzeBinaryFile(filePath: string): void {
  try {
    const result = analyzeBinary(filePath);
    console.log(formatAnalysisResult(result));
  } catch (error) {
    console.error(`Error analyzing binary: ${error}`);
    process.exit(1);
  }
}